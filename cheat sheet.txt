db == database

to view databases that already exist on your local machine:

  show dbs

collection == collection of documents; use name of collection you're
querying. Any time a collection is referenced that doesn't exist, it will be
created.

generic == db.collection.method()

To view all collections in your current database:

  show collections

If your database is books and your collection is george_orwell, you would do:
  
  use books
  db.orwell.method

To read a document, simply do:

  db.collection.find() // Returns all documents in a collection,
  // unless parameters are specified. Will return all documents matching the
  // parameters specified.
  
  Parameters look like JSON, for instance, if we want to return all books in
  the orwell collection, we would do:

    db.orwell.find()

  If we wanted to find only Animal Farm, it would look like:

    db.orwell.find({"title": "Animal Farm"})

  You may do this with any combination of parameters in JSON-style format. For
  instance, if there were two books named Animal Farm written by George Orwell
  (there aren't, just for the sake of illustration), we could narrow it down
  to one written in 1945:

    db.orwell.find({
        "title": "Animal Farm",
        "year": 1945
    })

  Notice that numbers are represented without quotes, just like in JSON. This
  of course applies to booleans as well. So, if we wanted to find all books
  written by Orwell that we already read, we could do:

    db.orwell.find({"read": true})

Here are some CRUD methods:

use db // creates database with name db if it doesn't already exist

CReate:

  db.collection.insertOne() // Inserts a single document into a collection;
  // creates the collection if it doesn't exist

    You may insert a document into a collection with any parameters
    whatsoever. Unlike in SQL, NoSQL platforms such as MongoDB don't require
    that you follow any pre-established schema or format. There will be no
    empty columns, or columns with default values, unless explicitly specified.

    So if we were to enter:

      db.orwell.insertOne({
          "title": "Homage to Catalonia",
          "year": 1938,
          "year published in US": 1952,
          "read": false
      })

    Followed by:

      db.orwell.insertOne({
          "title": "1984",
          "year": 1949,
          "read": true
      })

    The latter document would not have an empty "year published in US"
    property like it would if we were using a predefined schema with an SQL
    platform.

  The only exception to this rule is with the _id field. By default, this
  field will be a unique hexadecimal string. You may specify _id manually, but
  the insertion will throw an error if the string you enter is not unique.

  db.collection.insertMany() // Inserts several documents into a collection

    This looks like an array of JSON objects, like this:

    db.orwell.insertMany([{
      "title": "Burmese Days",
      "year": 1934
    }, {
      "title": "The Road to Wigan Pier",
      "year": 1937
    }])

    The rules for inserting a single document apply the same way here.

Update:

  db.collection.updateOne() // update a single document

  db.collection.updateMany() // update several documents

  db.collection.replaceOne() // removes and replaces a single document;
  without parameters, this is the first document returned

Delete:

  db.collection.deleteOne() // deletes a single document; without parameters,
  this is the first document returned

  db.collection.deleteMany() // deletes several documents
